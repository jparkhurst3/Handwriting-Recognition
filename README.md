# Handwriting-Recognition
An original handwriting recognition algorithm created for CS 1332. Can recognize any number within a .jpg file with 70% accuracy. Written in java using IntelliJ.

CS 1332 Individual Project Handwriting Recognition Algorithm

Joanna Parkhurst

ABSTRACT I used the pixels of a jpeg file as individual data structures to create a black/white template for any given photo. Comparing photos of handwritten numbers to a database of templates I created, the algorithm correctly estimated 60% of the numbers.

PROJECT PROPOSAL In search of a different kind of data structure, I decided upon a handwriting recognition project while daydreaming about a planning/scheduling app that can read your sticky notes and to-do lists for you. After researching different approaches, I’ve decided to do the following. First, I will collect samples of handwriting from friends to create a database of templates. Second, I will create a class to take a picture (jpg), covert it to greyscale, crop the writing, divide the picture into a grid, and then find the average greyscale value of each grid. Lastly, I will compare the templates in my database to the given picture and return the template value that matches the picture most accurately. In order to simplify this project into something more manageable for one person and five weeks, I will test only numbers (integers zero through nine) and process one number at a time (rather than a string of numbers). [Submitted on 6/22/15]

RESEARCH While researching handwriting algorithms (1), I learned that there were three different approaches: 1. Size Normalization and Template Matching 2. Structural Analysis 3. Contour Analysis I chose to pursue the first approach because it seemed the most practical.

STEP ONE: HANDWRITING TEMPLATES In order to create a database of handwriting templates, I created ten 10x10 grids on graph paper and had 20 friends fill out the numbers 0 through 9. Although the age range of my friends was limited, I asked ten men and ten women. They all used a highlighter and I encouraged them to fill the entire height of the grid with the number and write “casually” (not focus on creating a perfect number). From there I viewed each template, marked which squares within the grid were mostly filled in and created a string for each template. I entered a 0 for each square that was mostly empty and a 1 for each grid that was mostly full. These strings are the basis of my handwriting template “database”. I added each string to an array named templateArray within the “Templates.java” class.

STEP TWO: SIZE NORMALIZATION & ENCODING The next step in this algorithm was taking a photo and converting it into a similar string that I could compare to the database. In order for this step to work, a picture needs to have a height of at least 100 pixels after it has been cropped to only show the number. The “Image.java” class has the following methods: Grayscale – Iterates through each pixel and converts each pixel to grayscale using the “Luminosity” Formula (2) which multiples each red, green, and blue value by a certain fraction. Returns the image. In all cases this method is O(n). Crop – Finds a top and bottom boundary of the picture when five pixels in a line are over the grey threshold I set. Rounds the top boundary down and the bottom boundary up to the nearest multiple of ten. If the picture is less wide than the distance between the top and bottom boundary, it leaves the left and right boundaries as zero and the width respectively. Otherwise it sets the width to equal the height so that the image returned by crop is a square. Worst case this method is O(n). AverageGrid – Divides the image height and width by ten (hence cropping to a multiple of ten) to create grids over the image. This resembles the grids of the templates. For each pixel in the grid, it counts the number of pixels above and below the grey threshold. If there are more “white” pixels than “black” pixels, that grid was given a zero. If “black” pixels outweighed the “white” pixels, that grid was given a one. An ArrayList containing all of the numbers is returned. This method is also O(n).

STEP THREE: COMPARING & MEASURING ACCURACY The final step is to compare the image to the templates. The class “Compare.java” takes in an ArrayList returned from the AverageGrid method in Image.java. turnIntoString – Takes the given array and converts it into a string. All cases O(100). findMatches ¬– Compares the image’s string to each string in the template array and creates an array of how accurate each template is. All cases O(100 * 20)  O(2,000). bestMatch – Finds the index of the highest accuracy from the accuracy array, and returns the number associated with that template. O(100).

TESTING & RESULTS Using pictures of my own handwriting that I took on my phone, some of the numbers wouldn’t process correctly. I encountered an “ArrayOutOfBounds” exception on four of the ten numbers and can’t figure out why – all of the pictures are the same size, in the same lighting, and generally same format. I believe that it has to do with the quality of the picture, specifically the blurriest. I replaced those numbers with “handwritten” numbers from google image. Here are my results: Number Replaced? Estimate Match? 0 NO 2 NO 1 YES 1 YES 2 NO 2 YES 3 NO 1 NO 4 YES 1 NO 5 YES 5 YES 6 YES 6 YES 7 NO 7 YES 8 NO 1 NO 9 NO 9 YES With this test, 6 out of 10 of the pictures were estimated correctly. Not bad! The running time for the replaced images is significantly faster because they are smaller than the other images. Since findMatches is the most expensive method in the recognition algorithm, the size of the picture is directly correlated to the runtime.

WHAT I WOULD DO MOVING FORWARD  Increase number of grids on pictures from 10x10 to 50x50 or 100x100  Add to template database  Use the picture cropping and averaging method to file templates (rather than by hand)  Take better pictures of numbers (not blurry or with yellow/dark background)  Add a class to separate numbers from a list of numbers in a picture  Sort black/white values by rgb values so that picture doesn’t need to be grayscaled  Improve the running time of template matching by exiting individual iterations when accuracy is already less than a certain threshold  Add letters and symbols! Sources: 1. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.259.3553&rep=rep1&type=pdf 2. http://www.johndcook.com/blog/2009/08/24/algorithms-convert-color-grayscale/

This project is maintained by jparkhurst3
